<!--
Copyright 2025 Loom Pattern Designer Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Loom Pattern Designer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        h1 {
            margin-bottom: 20px;
            color: #333;
        }

        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 4px;
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group label {
            font-weight: bold;
            color: #555;
        }

        .control-group input,
        .control-group select {
            padding: 5px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        button {
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        button:hover {
            background-color: #45a049;
        }

        .warp-color-bar {
            display: inline-grid;
            gap: 1px;
            margin-bottom: 5px;
        }

        .weft-color-bar {
            display: inline-grid;
            gap: 1px;
            margin-right: 5px;
        }

        .color-item {
            width: 20px;
            height: 20px;
            border: 1px solid #333;
            cursor: pointer;
            position: relative;
        }

        .color-item:hover {
            opacity: 0.7;
            box-shadow: 0 0 3px rgba(0,0,0,0.5);
        }

        .color-item input[type="color"] {
            position: absolute;
            width: 100%;
            height: 100%;
            border: none;
            cursor: pointer;
            opacity: 0;
        }

        .loom-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            grid-template-rows: auto 1fr;
            gap: 10px;
            margin-top: 20px;
        }

        .grid-label {
            font-weight: bold;
            color: #666;
            padding: 5px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .threading-section {
            grid-column: 2;
            grid-row: 1;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .tieup-section {
            grid-column: 3;
            grid-row: 1;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            margin-left: 10px;
        }

        .drawdown-section {
            grid-column: 2;
            grid-row: 2;
            display: flex;
            align-items: flex-start;
        }

        .treadling-section {
            grid-column: 3;
            grid-row: 2;
            display: flex;
            align-items: flex-start;
            margin-left: 10px;
        }

        .grid {
            display: inline-grid;
            gap: 1px;
            background-color: #ccc;
            border: 2px solid #333;
            user-select: none;
        }

        .cell {
            width: 20px;
            height: 20px;
            background-color: white;
            cursor: pointer;
            border: 1px solid #ddd;
        }

        .cell:hover {
            opacity: 0.7;
        }

        .cell.active {
            background-color: #333;
        }

        .cell.warp {
            background-color: #2196F3;
        }

        .cell.weft {
            background-color: #FF9800;
        }

        .info {
            margin-top: 20px;
            padding: 15px;
            background-color: #e3f2fd;
            border-radius: 4px;
            border-left: 4px solid #2196F3;
        }

        .info h3 {
            margin-bottom: 10px;
            color: #1976D2;
        }

        .info ul {
            margin-left: 20px;
            color: #555;
        }

        .info li {
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Loom Pattern Designer</h1>

        <div class="controls">
            <div class="control-group">
                <label for="shafts">Shafts:</label>
                <input type="number" id="shafts" min="4" max="16" value="8">
            </div>
            <div class="control-group">
                <label for="warpThreads">Warp Threads:</label>
                <input type="number" id="warpThreads" min="4" max="64" value="32">
            </div>
            <div class="control-group">
                <label for="treadles">Treadles:</label>
                <input type="number" id="treadles" min="4" max="16" value="8">
            </div>
            <div class="control-group">
                <label for="picks">Picks (Weft rows):</label>
                <input type="number" id="picks" min="4" max="64" value="32">
            </div>
            <div class="control-group">
                <label for="threadingPattern">Threading Pattern:</label>
                <select id="threadingPattern" onchange="applyThreadingPattern()">
                    <option value="">-- Select --</option>
                    <option value="straight">Straight Draw</option>
                    <option value="point">Point Twill</option>
                    <option value="reverse">Reverse</option>
                </select>
            </div>
            <div class="control-group">
                <label for="treadlingPattern">Treadling Pattern:</label>
                <select id="treadlingPattern" onchange="applyTreadlingPattern()">
                    <option value="">-- Select --</option>
                    <option value="straight">Straight</option>
                    <option value="reverse">Reverse</option>
                    <option value="point">Point</option>
                </select>
            </div>
            <div class="control-group">
                <label for="warpColorPattern">Warp Colors:</label>
                <select id="warpColorPattern" onchange="applyWarpColorPattern()">
                    <option value="">-- Select --</option>
                    <option value="solid">Solid Color</option>
                    <option value="alternating">Alternating (2 colors)</option>
                    <option value="rainbow">Rainbow</option>
                </select>
                <input type="color" id="warpColor1" value="#2196F3" title="Color 1">
                <input type="color" id="warpColor2" value="#FF9800" title="Color 2">
            </div>
            <div class="control-group">
                <label for="weftColorPattern">Weft Colors:</label>
                <select id="weftColorPattern" onchange="applyWeftColorPattern()">
                    <option value="">-- Select --</option>
                    <option value="solid">Solid Color</option>
                    <option value="alternating">Alternating (2 colors)</option>
                    <option value="rainbow">Rainbow</option>
                </select>
                <input type="color" id="weftColor1" value="#FF9800" title="Color 1">
                <input type="color" id="weftColor2" value="#2196F3" title="Color 2">
            </div>
            <button onclick="resetAll()">Clear All</button>
            <button onclick="loadSamplePattern()">Load Sample Pattern</button>
            <button onclick="exportPattern()">Export Pattern</button>
            <button onclick="document.getElementById('importFile').click()">Import Pattern</button>
            <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importPattern(event)">
        </div>

        <div class="loom-grid">
            <div class="grid-label" style="grid-column: 1; grid-row: 1;">Threading →</div>
            <div class="threading-section">
                <div id="warpColors" class="warp-color-bar"></div>
                <div id="threading" class="grid"></div>
            </div>

            <div class="tieup-section">
                <div class="grid-label">Tie-Up</div>
                <div id="tieup" class="grid"></div>
            </div>

            <div class="grid-label" style="grid-column: 1; grid-row: 2;">↓ Drawdown</div>
            <div class="drawdown-section">
                <div id="drawdown" class="grid"></div>
            </div>

            <div class="treadling-section">
                <div class="grid-label">Treadling</div>
                <div style="display: flex; gap: 5px;">
                    <div id="weftColors" class="weft-color-bar"></div>
                    <div id="treadling" class="grid"></div>
                </div>
            </div>
        </div>

        <div class="info">
            <h3>How to Use:</h3>
            <ul>
                <li><strong>Threading Pattern:</strong> Use the dropdown to apply common threading patterns (Straight Draw, Point Twill, Reverse)</li>
                <li><strong>Treadling Pattern:</strong> Use the dropdown to apply common treadling patterns (Straight, Reverse, Point)</li>
                <li><strong>Warp/Weft Color Patterns:</strong> Select a color pattern and choose colors, then apply (Solid, Alternating, Rainbow)</li>
                <li><strong>Threading:</strong> Click cells to manually assign each warp thread to a shaft (vertical columns = threads, horizontal rows = shafts)</li>
                <li><strong>Tie-Up:</strong> Click to connect treadles to shafts (columns = treadles, rows = shafts)</li>
                <li><strong>Treadling:</strong> Click to manually set the sequence of treadle presses (columns = treadles, rows = picks/rows of weaving)</li>
                <li><strong>Thread Colors:</strong> Click individual colored squares above the threading (warp) or beside the treadling (weft) to customize colors</li>
                <li><strong>Drawdown:</strong> The resulting weave pattern is automatically calculated using your thread colors</li>
            </ul>
        </div>
    </div>

    <script>
        let state = {
            shafts: 8,
            warpThreads: 32,
            treadles: 8,
            picks: 32,
            threading: [],
            tieup: [],
            treadling: [],
            warpColors: [],
            weftColors: []
        };

        function initializeState() {
            const shafts = parseInt(document.getElementById('shafts').value);
            const warpThreads = parseInt(document.getElementById('warpThreads').value);
            const treadles = parseInt(document.getElementById('treadles').value);
            const picks = parseInt(document.getElementById('picks').value);

            state.shafts = shafts;
            state.warpThreads = warpThreads;
            state.treadles = treadles;
            state.picks = picks;

            state.threading = Array(warpThreads).fill(null).map(() => Array(shafts).fill(false));
            state.tieup = Array(treadles).fill(null).map(() => Array(shafts).fill(false));
            state.treadling = Array(picks).fill(null).map(() => Array(treadles).fill(false));

            // Initialize colors if needed
            if (state.warpColors.length !== warpThreads) {
                state.warpColors = Array(warpThreads).fill('#2196F3');
            }
            if (state.weftColors.length !== picks) {
                state.weftColors = Array(picks).fill('#FF9800');
            }
        }

        function createGrid(containerId, rows, cols, clickHandler) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            container.style.gridTemplateColumns = `repeat(${cols}, 20px)`;
            container.style.gridTemplateRows = `repeat(${rows}, 20px)`;

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.onclick = () => clickHandler(row, col);
                    container.appendChild(cell);
                }
            }
        }

        function createColorPickers() {
            const warpColorsContainer = document.getElementById('warpColors');
            const weftColorsContainer = document.getElementById('weftColors');

            warpColorsContainer.innerHTML = '';
            weftColorsContainer.innerHTML = '';

            // Set grid layout for warp colors (horizontal)
            warpColorsContainer.style.gridTemplateColumns = `repeat(${state.warpThreads}, 20px)`;
            warpColorsContainer.style.gridTemplateRows = '20px';

            // Set grid layout for weft colors (vertical)
            weftColorsContainer.style.gridTemplateColumns = '20px';
            weftColorsContainer.style.gridTemplateRows = `repeat(${state.picks}, 20px)`;

            // Create warp color pickers
            for (let i = 0; i < state.warpThreads; i++) {
                const colorItem = document.createElement('div');
                colorItem.className = 'color-item';
                colorItem.style.backgroundColor = state.warpColors[i];
                colorItem.title = `Warp thread ${i + 1}`;

                const colorInput = document.createElement('input');
                colorInput.type = 'color';
                colorInput.value = state.warpColors[i];
                colorInput.addEventListener('change', (e) => {
                    state.warpColors[i] = e.target.value;
                    colorItem.style.backgroundColor = e.target.value;
                    updateDrawdown();
                });

                colorItem.appendChild(colorInput);
                warpColorsContainer.appendChild(colorItem);
            }

            // Create weft color pickers
            for (let i = 0; i < state.picks; i++) {
                const colorItem = document.createElement('div');
                colorItem.className = 'color-item';
                colorItem.style.backgroundColor = state.weftColors[i];
                colorItem.title = `Weft pick ${i + 1}`;

                const colorInput = document.createElement('input');
                colorInput.type = 'color';
                colorInput.value = state.weftColors[i];
                colorInput.addEventListener('change', (e) => {
                    state.weftColors[i] = e.target.value;
                    colorItem.style.backgroundColor = e.target.value;
                    updateDrawdown();
                });

                colorItem.appendChild(colorInput);
                weftColorsContainer.appendChild(colorItem);
            }
        }

        function toggleThreading(shaft, thread) {
            for (let s = 0; s < state.shafts; s++) {
                state.threading[thread][s] = (s === shaft);
            }
            updateGrids();
        }

        function toggleTieup(shaft, treadle) {
            state.tieup[treadle][shaft] = !state.tieup[treadle][shaft];
            updateGrids();
        }

        function toggleTreadling(pick, treadle) {
            for (let t = 0; t < state.treadles; t++) {
                state.treadling[pick][t] = (t === treadle);
            }
            updateGrids();
        }

        function applyThreadingPattern() {
            const pattern = document.getElementById('threadingPattern').value;
            if (!pattern) return;

            // Clear existing threading
            for (let i = 0; i < state.warpThreads; i++) {
                for (let s = 0; s < state.shafts; s++) {
                    state.threading[i][s] = false;
                }
            }

            if (pattern === 'straight') {
                // Straight draw: 1, 2, 3, 4, 1, 2, 3, 4...
                for (let i = 0; i < state.warpThreads; i++) {
                    const shaft = i % state.shafts;
                    state.threading[i][shaft] = true;
                }
            } else if (pattern === 'point') {
                // Point twill: 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2...
                const cycleLength = (state.shafts * 2) - 2;
                for (let i = 0; i < state.warpThreads; i++) {
                    const pos = i % cycleLength;
                    let shaft;
                    if (pos < state.shafts) {
                        shaft = pos;
                    } else {
                        shaft = (state.shafts * 2 - 2) - pos;
                    }
                    state.threading[i][shaft] = true;
                }
            } else if (pattern === 'reverse') {
                // Reverse: 4, 3, 2, 1, 4, 3, 2, 1...
                for (let i = 0; i < state.warpThreads; i++) {
                    const shaft = (state.shafts - 1) - (i % state.shafts);
                    state.threading[i][shaft] = true;
                }
            }

            updateGrids();
            // Reset dropdown
            document.getElementById('threadingPattern').value = '';
        }

        function applyTreadlingPattern() {
            const pattern = document.getElementById('treadlingPattern').value;
            if (!pattern) return;

            // Clear existing treadling
            for (let i = 0; i < state.picks; i++) {
                for (let t = 0; t < state.treadles; t++) {
                    state.treadling[i][t] = false;
                }
            }

            if (pattern === 'straight') {
                // Straight: 1, 2, 3, 4, 1, 2, 3, 4...
                for (let i = 0; i < state.picks; i++) {
                    const treadle = i % state.treadles;
                    state.treadling[i][treadle] = true;
                }
            } else if (pattern === 'reverse') {
                // Reverse: 4, 3, 2, 1, 4, 3, 2, 1...
                for (let i = 0; i < state.picks; i++) {
                    const treadle = (state.treadles - 1) - (i % state.treadles);
                    state.treadling[i][treadle] = true;
                }
            } else if (pattern === 'point') {
                // Point: 1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 3, 2...
                const cycleLength = (state.treadles * 2) - 2;
                for (let i = 0; i < state.picks; i++) {
                    const pos = i % cycleLength;
                    let treadle;
                    if (pos < state.treadles) {
                        treadle = pos;
                    } else {
                        treadle = (state.treadles * 2 - 2) - pos;
                    }
                    state.treadling[i][treadle] = true;
                }
            }

            updateGrids();
            // Reset dropdown
            document.getElementById('treadlingPattern').value = '';
        }

        function applyWarpColorPattern() {
            const pattern = document.getElementById('warpColorPattern').value;
            if (!pattern) return;

            const color1 = document.getElementById('warpColor1').value;
            const color2 = document.getElementById('warpColor2').value;

            if (pattern === 'solid') {
                // All threads same color
                for (let i = 0; i < state.warpThreads; i++) {
                    state.warpColors[i] = color1;
                }
            } else if (pattern === 'alternating') {
                // Alternating between two colors
                for (let i = 0; i < state.warpThreads; i++) {
                    state.warpColors[i] = (i % 2 === 0) ? color1 : color2;
                }
            } else if (pattern === 'rainbow') {
                // Rainbow gradient
                for (let i = 0; i < state.warpThreads; i++) {
                    const hue = (i / state.warpThreads) * 360;
                    state.warpColors[i] = `hsl(${hue}, 70%, 50%)`;
                }
            }

            createColorPickers();
            updateDrawdown();
            // Reset dropdown
            document.getElementById('warpColorPattern').value = '';
        }

        function applyWeftColorPattern() {
            const pattern = document.getElementById('weftColorPattern').value;
            if (!pattern) return;

            const color1 = document.getElementById('weftColor1').value;
            const color2 = document.getElementById('weftColor2').value;

            if (pattern === 'solid') {
                // All picks same color
                for (let i = 0; i < state.picks; i++) {
                    state.weftColors[i] = color1;
                }
            } else if (pattern === 'alternating') {
                // Alternating between two colors
                for (let i = 0; i < state.picks; i++) {
                    state.weftColors[i] = (i % 2 === 0) ? color1 : color2;
                }
            } else if (pattern === 'rainbow') {
                // Rainbow gradient
                for (let i = 0; i < state.picks; i++) {
                    const hue = (i / state.picks) * 360;
                    state.weftColors[i] = `hsl(${hue}, 70%, 50%)`;
                }
            }

            createColorPickers();
            updateDrawdown();
            // Reset dropdown
            document.getElementById('weftColorPattern').value = '';
        }

        function updateGrids() {
            updateThreadingDisplay();
            updateTieupDisplay();
            updateTreadlingDisplay();
            updateDrawdown();
        }

        function updateThreadingDisplay() {
            const container = document.getElementById('threading');
            const cells = container.querySelectorAll('.cell');

            cells.forEach(cell => {
                const shaft = parseInt(cell.dataset.row);
                const thread = parseInt(cell.dataset.col);
                cell.className = 'cell';
                if (state.threading[thread][shaft]) {
                    cell.classList.add('active');
                }
            });
        }

        function updateTieupDisplay() {
            const container = document.getElementById('tieup');
            const cells = container.querySelectorAll('.cell');

            cells.forEach(cell => {
                const shaft = parseInt(cell.dataset.row);
                const treadle = parseInt(cell.dataset.col);
                cell.className = 'cell';
                if (state.tieup[treadle][shaft]) {
                    cell.classList.add('active');
                }
            });
        }

        function updateTreadlingDisplay() {
            const container = document.getElementById('treadling');
            const cells = container.querySelectorAll('.cell');

            cells.forEach(cell => {
                const pick = parseInt(cell.dataset.row);
                const treadle = parseInt(cell.dataset.col);
                cell.className = 'cell';
                if (state.treadling[pick][treadle]) {
                    cell.classList.add('active');
                }
            });
        }

        function updateDrawdown() {
            const container = document.getElementById('drawdown');
            const cells = container.querySelectorAll('.cell');

            cells.forEach(cell => {
                const pick = parseInt(cell.dataset.row);
                const thread = parseInt(cell.dataset.col);
                cell.className = 'cell';

                const isWarpUp = calculateDrawdownCell(pick, thread);
                if (isWarpUp) {
                    cell.style.backgroundColor = state.warpColors[thread];
                } else {
                    cell.style.backgroundColor = state.weftColors[pick];
                }
            });
        }

        function calculateDrawdownCell(pick, thread) {
            const activeShafts = new Set();

            for (let t = 0; t < state.treadles; t++) {
                if (state.treadling[pick][t]) {
                    for (let s = 0; s < state.shafts; s++) {
                        if (state.tieup[t][s]) {
                            activeShafts.add(s);
                        }
                    }
                }
            }

            for (let s = 0; s < state.shafts; s++) {
                if (state.threading[thread][s]) {
                    return activeShafts.has(s);
                }
            }

            return false;
        }

        function initialize() {
            initializeState();
            createGrid('threading', state.shafts, state.warpThreads, toggleThreading);
            createGrid('tieup', state.shafts, state.treadles, toggleTieup);
            createGrid('treadling', state.picks, state.treadles, toggleTreadling);
            createGrid('drawdown', state.picks, state.warpThreads, () => {});
            createColorPickers();
            updateGrids();
        }

        function resetAll() {
            initializeState();
            createColorPickers();
            updateGrids();
        }

        function loadSamplePattern() {
            initializeState();

            for (let i = 0; i < state.warpThreads; i++) {
                const shaft = i % state.shafts;
                state.threading[i][shaft] = true;
            }

            for (let t = 0; t < state.treadles; t++) {
                const shaft1 = t % state.shafts;
                const shaft2 = (t + 1) % state.shafts;
                state.tieup[t][shaft1] = true;
                state.tieup[t][shaft2] = true;
            }

            for (let p = 0; p < state.picks; p++) {
                const treadle = p % state.treadles;
                state.treadling[p][treadle] = true;
            }

            updateGrids();
        }

        function exportPattern() {
            const exportData = {
                version: "1.0",
                settings: {
                    shafts: state.shafts,
                    warpThreads: state.warpThreads,
                    treadles: state.treadles,
                    picks: state.picks
                },
                threading: state.threading,
                tieup: state.tieup,
                treadling: state.treadling,
                warpColors: state.warpColors,
                weftColors: state.weftColors
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);

            const link = document.createElement('a');
            link.href = url;
            link.download = `loom-pattern-${new Date().toISOString().slice(0, 10)}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function importPattern(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importData = JSON.parse(e.target.result);

                    // Update settings
                    document.getElementById('shafts').value = importData.settings.shafts;
                    document.getElementById('warpThreads').value = importData.settings.warpThreads;
                    document.getElementById('treadles').value = importData.settings.treadles;
                    document.getElementById('picks').value = importData.settings.picks;

                    // Initialize with new settings
                    initializeState();

                    // Load pattern data
                    state.threading = importData.threading;
                    state.tieup = importData.tieup;
                    state.treadling = importData.treadling;

                    // Load colors if they exist in the import data
                    if (importData.warpColors) {
                        state.warpColors = importData.warpColors;
                    }
                    if (importData.weftColors) {
                        state.weftColors = importData.weftColors;
                    }

                    // Recreate grids and update display
                    createGrid('threading', state.shafts, state.warpThreads, toggleThreading);
                    createGrid('tieup', state.shafts, state.treadles, toggleTieup);
                    createGrid('treadling', state.picks, state.treadles, toggleTreadling);
                    createGrid('drawdown', state.picks, state.warpThreads, () => {});
                    createColorPickers();
                    updateGrids();

                    alert('Pattern imported successfully!');
                } catch (error) {
                    alert('Error importing pattern: ' + error.message);
                }
            };
            reader.readAsText(file);

            // Reset file input so the same file can be imported again
            event.target.value = '';
        }

        document.getElementById('shafts').addEventListener('change', initialize);
        document.getElementById('warpThreads').addEventListener('change', initialize);
        document.getElementById('treadles').addEventListener('change', initialize);
        document.getElementById('picks').addEventListener('change', initialize);

        initialize();
    </script>
</body>
</html>
